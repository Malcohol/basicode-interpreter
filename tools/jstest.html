<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">

    <style>
        .screen-wrapper {
            font-size: 1rem;
            width: 79ch;
            padding:0;
            display:table;
            padding: 0.5rem 0.5rem 0.5rem 0.5rem;
            border-radius: 0.8rem;
            border: 1px solid lightblue;
            text-align: center;
            background-color: white;
        }
        #input, #output {
            text-align: left;
            vertical-align: middle;
            font-family: monospace;
            font-size: 1rem;
            outline: none;
            overflow: hidden;
            border: 0;
            padding: 0;
            margin: auto;
            transform: scaleX(2);
            background-color: lightblue;
        }
        #input {
            width: 40ch;
            height: 2rem;
            resize: none;
        }
        #output {
            width: 40ch;
            height: 24rem;
        }
    </style>

    <script>
        "use strict";

        ///////////////////////////////////////////////////////////////////////
        // For a similar, GPL-licensed interpreter
        // see https://github.com/MarquisdeGeek/basicode
        // which is (c) 2012 by Steven Goodwin
        //
        // I'd like to acknowledge Steven's interpreter as a source of inspiration.
        // However, this interpreter does not take code from his.


        ///////////////////////////////////////////////////////////////////////
        // interpreter state objects

        function Data()
        {
            this.store = [];
            this.pointer = 0;

            this.read = function()
            {
                if (this.pointer < this.store.length) {
                    this.pointer += 1;
                    return this.store[this.pointer-1];
                }
                else {
                    throw 'Out of Data';
                }
            };

            this.restore = function()
            {
                this.pointer = 0;
            };

            this.data = function(new_data)
            {
                this.store = this.store.concat(new_data);
            }

        }

        ///////////////////////////////////////////////////////////////////////
        // types, variables, arrays

        function defaultValue(name)
        // default value for type given by name
        {
            var default_value = 0;
            if (name.slice(-1) === '$') default_value = '';
            return default_value;
        }

        function matchType(name, value)
        {
            var string_name = (name.slice(-1) === '$');
            var string_value = typeof value === 'string';
            if (!string_value && typeof value !== 'number') {
                throw 'Type mismatch: unknown type';
            }
            if (string_name !== string_value) {
                throw 'Type mismatch';
            }
        }

        function Variables()
        {
            this.vars = {};
            this.dims = {};

            this.allocate = function(name, indices)
            // allocate an array
            {
                // no redefinitions allowed
                if (name in this.dims || name in this.vars) throw 'Duplicate definition';
                // BASICODE arrays may have at most two indices
                if (indices.length > 2) throw 'Subscript out of range: too many array dimensions';

                // set default to empty string if string name, 0 otherwise
                var default_value = defaultValue(name);

                function allocateLevel(indices) {
                    if (indices.length === 0) return default_value;
                    else {
                        // allocate subarray; BASICODE arrays span 0..x inclusive
                        var arr = new Array(indices[0]+1);
                        // feed remaining arguments to recursive call
                        var argarray = indices.slice(1);
                        // allocate deeper level
                        for (var i=0; i < arr.length; ++i) {
                            arr[i] = allocateLevel(argarray);
                        }
                        return arr;
                    }
                };

                // I'm assuming a name is *either* a scalar *or* an array
                // this is not true in e.g. GW-BASIC, but I think it's true in BASICODE
                this.dims[name] = indices;
                this.vars[name] = allocateLevel(indices);
            }

            this.checkSubscript = function(name, indices)
            {
                if (!(name in this.dims)) {
                    if (indices.length === 0) {
                        this.vars[name] = defaultValue(name);
                        this.dims[name] = [];
                    }
                    else {
                        throw 'Subscript out of range: array not dimensioned';
                    }
                }
                else if (indices.length !== this.dims[name].length) {
                    throw 'Subscript out of range: incorrect number of dimensions';
                }
                else {
                    for (var i=0; i < indices.length; ++i) {
                        if (indices[i] < 0 || indices[i] > this.dims[name][i]) {
                            throw 'Subscript out of range: index '+i+' out of bounds';
                        }
                    }
                }
            }

            this.assign = function(value, name, indices)
            // set a variable
            {
                this.checkSubscript(name, indices);

                if (indices.length === 0) {
                    this.vars[name] = value;
                }
                else if (indices.length === 1) {
                    this.vars[name][indices[0]] = value;
                }
                else {
                    this.vars[name][indices[0]][indices[1]] = value;
                }
            };

            this.retrieve = function(name, indices)
            // retrieve a variable
            {
                this.checkSubscript(name, indices);

                if (indices.length === 0) {
                    return this.vars[name];
                }
                else if (indices.length === 1) {
                    return this.vars[name][indices[0]];
                }
                else {
                    return this.vars[name][indices[0]][indices[1]];
                }
            };
        }

        //////////////////////////////////////////////////////////////////////
        // tokens

        function tokenSeparator(bracket_char)
        {
            this.token_type = bracket_char;
            this.payload = bracket_char;
        }

        function tokenLiteral(value)
        {
            this.token_type = 'literal';
            this.operation = function opLiteral(x) { return x; };
            this.payload = value;
        }

        function tokenName(value)
        {
            this.token_type = 'name';
            this.payload = value;
        }

        function newFunctionToken(keyword) {
            return (function() {
                return (new function tokenFunction() {
                    this.token_type = 'function';
                    this.payload = keyword;
                }() );
            } );
        }
        function newStatementToken(keyword) {
            return (function() {
                return (new function tokenStatement() {
                    this.token_type = 'statement';
                    this.payload = keyword;
                }() );
            } );
        }
        function newOperatorToken(keyword, narity, precedence, operation) {
            return (function() {
                return (new function tokenOperator() {
                    this.token_type = 'operator';
                    this.payload = keyword;
                    this.narity = narity;
                    this.precedence = precedence;
                    this.operation = operation;
                }() );
            } );
        }

        const SYMBOLS = {
            '^': newOperatorToken('^', 2, 12, function opPower(x, y) { return Math.pow(x, y); }),
            '*': newOperatorToken('*', 2, 11, function opMultiply(x, y) { return x * y; }),
            '/': newOperatorToken('/', 2, 11, function opDivide(x, y) { return x / y; }),
            // + adds numbers or concatenates strings
            // does BASICODE accept unary + ?
            '+': newOperatorToken('+', 2, 8, function opAddOrConcatenate(x, y) { return x + y; }),
            // - can be unary negation or binary subtraction
            '-': newOperatorToken('-', null, 8, function opSubtractOrNegate(x, y) { if (y === undefined) return -x; else return x - y; }),
            '=': newOperatorToken('>=', 2, 7, function opEqual(x, y) { return (x === y); }),
            '>': newOperatorToken('>', 2, 7, function opGreaterThan(x, y) { return (x > y); }),
            '>=': newOperatorToken('>=', 2, 7, function opGreaterThanOrEqual(x, y) { return (x >= y); }),
            '<': newOperatorToken('>=', 2, 7, function opLessThan(x, y) { return (x > y); }),
            '<=': newOperatorToken('>=', 2, 7, function opLessThanOrEqual(x, y) { return (x <= y); }),
            '<>': newOperatorToken('>=', 2, 7, function opNotEqual(x, y) { return (x !== y); }),
        }

        const KEYWORDS = {
            'ABS': newFunctionToken('ABS'),
            'AND': newOperatorToken('AND', 2, 5, function opAnd(x, y) { return (x && y); }),
            'ASC': newFunctionToken('ASC'),
            'ATN': newFunctionToken('ATN'),
            'CHR$': newFunctionToken('CHR$'),
            'COS': newFunctionToken('COS'),
            'DATA': newStatementToken('DATA'),
            'DIM': newStatementToken('DIM'),
            'EXP': newFunctionToken('EXP'),
            'FOR': newStatementToken('FOR'),
            'GOSUB': newStatementToken('GOSUB'),
            'GOTO': newStatementToken('GOTO'),
            'IF': newStatementToken('IF'),
            'INPUT': newStatementToken('INPUT'),
            'INT': newFunctionToken('INT'),
            'LEFT$': newFunctionToken('LEFT$'),
            'LEN': newFunctionToken('LEN'),
            'LET': newStatementToken('LET'),
            'LOG': newFunctionToken('LOG'),
            'MID$': newFunctionToken('MID$'),
            'NEXT': newStatementToken('NEXT'),
            'NOT': newOperatorToken('NOT', 1, 6, function opNot(x) { return (!x); }),
            'ON': newStatementToken('ON'),
            'OR': newOperatorToken('OR', 2, 4, function opOr(x, y) { return (x || y); }),
            'PRINT': newStatementToken('PRINT'),
            'READ': newStatementToken('READ'),
            'REM': newStatementToken('REM'),
            'RESTORE': newStatementToken('RESTORE'),
            'RETURN': newStatementToken('RETURN'),
            'RIGHT$': newFunctionToken('RIGHT$'),
            'SGN': newFunctionToken('SGN'),
            'SIN': newFunctionToken('SIN'),
            'SQR': newFunctionToken('SQR'),
            'STEP': newStatementToken('STEP'),
            'TAB': newFunctionToken('TAB'),
            'TAN': newFunctionToken('TAN'),
            'THEN': newStatementToken('THEN'),
            'TO': newStatementToken('TO'),
            'VAL': newFunctionToken('VAL'),
        }

        // additional reserved words: AS, AT, FN, GR, IF, LN, PI, ST, TI, TI$


        //////////////////////////////////////////////////////////////////////
        // lexer


        function tokenise(expr_string)
        // convert expression string to list of tokens
        {
            var pos = 0;

            function isNumberChar(char)
            {
                return (char >= '0' && char <= '9');
            }

            function isAlphaChar(char)
            {
                return (char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z');
            }

            function readString() {
                // read a double-quoted string literal
                var start_pos = pos;
                // skip start and closing quotes
                for (++pos; (pos < expr_string.length && expr_string[pos] !== '"'); ++pos);
                if (pos === expr_string.length) {
                    throw 'Syntax error: no closing `"`';
                }
                return expr_string.slice(start_pos+1, pos);
            }

            function readInteger() {
                // read an unsigned integer literal (i.e. a string of numbers)
                var start_pos = pos;
                for (; pos < expr_string.length-1; ++pos){
                    if (!isNumberChar(expr_string[pos+1])) break;
                }
                return expr_string.slice(start_pos, pos+1);
            }

            function readName() {
                // read a name (variable or keyword)
                var start_pos = pos;
                for (; pos < expr_string.length-1; ++pos){
                    // the name can end in at most one $
                    if (expr_string[pos+1] === '$') {
                        ++pos;
                        break;
                    }
                    if (!isAlphaChar(expr_string[pos+1]) && !isNumberChar(expr_string[pos+1])) break;
                }
                return expr_string.slice(start_pos, pos+1);
            }

            var expr_list = [];
            for (pos=0; pos < expr_string.length; ++pos) {
                var char = expr_string[pos];
                if (char in SYMBOLS) {
                    var operator = char;
                    // two-symbol operators all start with lt or gt
                    if (char == '<' || char == '>') {
                        if (pos+1 < expr_string.length) {
                            var char2 = expr_string[pos+1];
                            if (char2 == '<' || char2 == '>' || char2 == '=') {
                                operator += char2;
                                ++pos;
                            }
                        }
                    }
                    expr_list.push(SYMBOLS[operator]());
                }
                else if (char == '(' || char == ')' || char == ',' || char == ';' || char == ':') {
                    expr_list.push(new tokenSeparator(char));
                }
                // double quotes, starts a string
                else if (char === '"') {
                    expr_list.push(new tokenLiteral(readString()));
                }
                // numeric character, starts a number literal
                // for VAL(), we should also accept a - here later
                else if (isNumberChar(char) || char === '.') {
                    var mantissa = 0;
                    var decimal = 0;
                    var exponent = 0;
                    if (isNumberChar(char)) {
                        mantissa = readInteger();
                    }
                    else {
                        --pos;
                    }
                    if (pos+1 < expr_string.length && expr_string[pos+1] === '.') {
                        ++pos;
                        if (pos+1 < expr_string.length && isNumberChar(expr_string[pos+1])) {
                            ++pos;
                            decimal = readInteger();
                        }
                    }
                    if (pos+1 < expr_string.length && (expr_string[pos+1] === 'E' || expr_string[pos+1] === 'e')) {
                        ++pos;
                        if (pos+1 < expr_string.length && (isNumberChar(expr_string[pos+1]) || expr_string[pos+1] === '-')) {
                            ++pos;
                            if (expr_string[pos+1] === '-') {
                                ++pos;
                                exponent = '-' + readInteger();
                            }
                            else {
                                exponent = readInteger();
                            }
                        }
                    }
                    expr_list.push(new tokenLiteral(
                        parseFloat(mantissa + '.' + decimal + 'e' + exponent)));
                }
                else if (isAlphaChar(char)) {
                    var name = readName();
                    if (name in KEYWORDS) {
                        // call function that calls new on a constructor
                        expr_list.push(KEYWORDS[name]());
                    }
                    else {
                        expr_list.push(new tokenName(name));
                    }
                }
                else if (char !== ' ') {
                    throw 'Syntax error: unexpected symbol `'+ char + '`';
                }
            }
            return expr_list;
        }

        //////////////////////////////////////////////////////////////////////
        // expression parser

        function Node(func, node_args)
        {
            this.func = func;
            this.args = node_args;

            // traverse AST to evaluate this node and all its subnodes
            this.evaluate = function()
            {
                var args = this.args.slice()
                for (var i = 0; i < args.length; ++i) {
                    if (args[i] instanceof Node) {
                        args[i] = args[i].evaluate();
                    }
                }
                // call the function with the array supplied as arguments
                return this.func.apply(this, args);
            };
        }

        function ExpressionParser(vars)
        {
            function opRetrieve(name) {
                var indices = [].slice.call(arguments, 1);
                return vars.retrieve(name, indices);
            }

            this.parse = function(expr_list)
            // parse expression from a list of tokens to an AST
            // variation of Dijkstra's shunting-yard algorithm, following PC-BASIC
            {
                var stack = [];
                var units = [];
                var token = null;
                var exit_loop = false;
                //for (var pos = 0; pos < expr_list.length; ++pos) {
                while (expr_list.length > 0) {
                    var last = token;
                    token = expr_list.shift();
                    if (token.token_type === 'operator') {
                        // only a unary operator after another operator or at the start
                        var narity = 2;
                        if (last === null || last.token_type === 'operator') {
                            // narity 1: prefix, 2: binary infix
                            // narity null is for - which can be prefix or infix
                            narity = 1;
                        }
                        if (token.narity !== null && token.narity !== narity) {
                            throw 'Syntax error: unexpected operator type';
                        }
                        if (narity === 2) {
                            // drain stack until precedence is matched
                            this.drain(token.precedence, stack, units);
                        }
                        // (copy and?) override the narity of - before pushing
                        token.narity = narity;
                        stack.push(token)
                    }
                    else if (last === null || last.token_type === 'operator') {
                        switch (token.token_type) {
                            case 'function':
                                // TODO
                                break;
                            case '(':
                                // recursive call, gets a Node object containing AST
                                units.push(this.parse(expr_list));
                                var bracket = expr_list.shift(token);
                                if (bracket.token_type !== ')') {
                                    throw 'Syntax error: expected `)`, got `' + bracket.payload + '`';
                                }
                                break;
                            case 'literal':
                                units.push(new Node(token.operation, [token.payload]));
                                break;
                            case 'name':
                                var indices = this.parseArguments(expr_list);
                                units.push(new Node(opRetrieve, [token.payload].concat(indices)));
                                break;
                            default:
                                expr_list.unshift(token);
                                exit_loop = true;
                                break;
                        }
                    }
                    else {
                        expr_list.unshift(token);
                        break;
                        //throw 'Syntax error: unexpected unit ' + token.payload;
                    }
                    if (exit_loop) {
                        break;
                    }
                }
                this.drain(0, stack, units);
                return units[0];
            };

            this.parseArguments = function(expr_list)
            {
                var args = [];
                if (expr_list.length > 0 && expr_list[0].token_type === '(') {
                    expr_list.shift();
                    while (expr_list.length > 0) {
                        args.push(this.parse(expr_list));
                        var token = expr_list.shift();
                        if (token.token_type === ')') break;
                        if (token.token_type !== ',') {
                            throw 'Syntax error: expected `,`, got `'+token.payload+'`';
                        }
                    }
                    if (token.token_type !== ')') {
                        throw 'Syntax error: missing `)`';
                    }
                }
                return args;
            }

            this.drain = function(precedence, stack, units)
            {
                while ((stack.length > 0)) {

                    if (precedence > stack[stack.length-1].precedence) {
                        break;
                    }
                    var token = stack.pop();
                    var args = units.slice(units.length - token.narity);
                    // we need to pop without slicing the units
                    // to affect the mutable argument
                    for (var i=0; i < args.length; ++i) {
                        units.pop();
                    }
                    units.push(new Node(token.operation, args));
                }
                return units;
            };
        };

        function App(output_element, input_element)
        {
            this.clear = function() {
                output_element.innerHTML = '';
            };

            this.write = function(output) {
                output_element.innerHTML += output.replace('<', '&lt;').replace('>', '&gt;');
            };

            this.read = function() {
                return input_element.value;
            }
        }


    </script>
</head>

<body>
    <div class="screen-wrapper"><textarea id="input"></textarea></div>
    <button id="get_output">Test</button>
    <div class="screen-wrapper">
        <pre id="output">Output here</pre>
    </div>

    <script>
        "use strict";

        var app = new App(
            document.getElementById("output"),
            document.getElementById("input"));

        document.getElementById("get_output").onclick = function () {
            // screen + input test
            var input = app.read();
            app.clear();
            app.write('you typed: ' + input + '\n');
            app.write('We can write <br>\n');
            app.write('We can write \\\n');

            // variable test
            var vars = new Variables();
            vars.assign(10, 'A$', []);
            vars.assign(11, 'A$', []);
            vars.allocate('B$', [10]);
            vars.assign(12, 'B$', [1]);
            vars.allocate('C', [100,100]);
            vars.assign(12, 'C', [1,100]);
            app.write('A$ = ' + vars.retrieve('A$', []) + '\n');
            app.write('B$(1) = ' + vars.retrieve('B$', [1]) + '\n');
            app.write('C(1,100) = ' + vars.retrieve('C', [1, 100]) + '\n');

            // data reader test
            var data = new Data();
            data.data([1,2,3,4,5]);
            app.write(data.read().toString(10) + data.read().toString(10)+ '\n');

            // evaluate test
            var node = new Node(function(a, b) { return a+b; }, [1, 5]);
            var node2 = new Node(function(a, b) { return a*b; }, [node, 5]);
            app.write(node2.evaluate().toString(10) + '\n');

            // expression parser test
            var expr_list = [
                new tokenSeparator('('),
                new tokenLiteral(3), SYMBOLS['+'](),
                new tokenLiteral(4), SYMBOLS['*'](), new tokenLiteral(2),
                new tokenSeparator(')'),
                SYMBOLS['/'](), new tokenLiteral(5),
            ];
            var parser = new ExpressionParser(vars);
            var ast = parser.parse(expr_list);
            app.write('evaluate: ' + ast.evaluate() + '\n');

            // lexer test
            app.write((parser.parse(tokenise('1-2')).evaluate() == -1) + '\n');
            app.write((parser.parse(tokenise('-1')).evaluate() == -1) + '\n');
            app.write((parser.parse(tokenise('.5')).evaluate() == 0.5) + '\n');
            app.write((parser.parse(tokenise('-.5')).evaluate() == -0.5) + '\n');
            app.write((parser.parse(tokenise('1.2e2')).evaluate() == 120) + '\n');
            app.write((parser.parse(tokenise('1.2e-2')).evaluate() == 0.012) + '\n');
            app.write((parser.parse(tokenise('((1=1)) OR (1=0)')).evaluate() == true) + '\n');
            app.write((parser.parse(tokenise('((1=1)) AND (1=0)')).evaluate() == false) + '\n');
            app.write((parser.parse(tokenise('NOT 0')).evaluate() == true) + '\n');

            var expr_str = input;
            if (expr_str.length) {
                expr_list = tokenise(expr_str);
                var str2 = '';
                for (var i=0; i < expr_list.length; ++i) {
                    str2 += expr_list[i].token_type +' ' + expr_list[i].payload+',';
                }
                ast = parser.parse(expr_list);

                var rem = 'remainder of expr: ';
                for (var i=0; i < expr_list.length; ++i)
                    rem += expr_list[i].payload;
                console.log(rem);

                app.write('evaluate ' + expr_str + ' = ' + ast.evaluate() + '\n');
            }

            app.write('done');
        };
    </script>
</body>
</html>
